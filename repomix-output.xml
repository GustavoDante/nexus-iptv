This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app/api/data/route.ts
app/dashboard/favorites/page.tsx
app/dashboard/layout.tsx
app/dashboard/live/[categoryId]/page.tsx
app/dashboard/live/all/page.tsx
app/dashboard/live/page.tsx
app/dashboard/loading.tsx
app/dashboard/movies/[categoryId]/page.tsx
app/dashboard/movies/all/page.tsx
app/dashboard/movies/page.tsx
app/dashboard/page.tsx
app/dashboard/series/[categoryId]/page.tsx
app/dashboard/series/all/page.tsx
app/dashboard/series/page.tsx
app/favicon.ico
app/globals.css
app/layout.tsx
app/page.tsx
components.json
components/app-sidebar.tsx
components/category-list.tsx
components/channel-card.tsx
components/content-info-dialog.tsx
components/content-layout.tsx
components/login-form.tsx
components/search-input.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/dialog.tsx
components/ui/form.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/scroll-area.tsx
components/ui/separator.tsx
components/ui/sheet.tsx
components/ui/sidebar.tsx
components/ui/skeleton.tsx
components/ui/tooltip.tsx
components/video-player.tsx
components/virtual-grid.tsx
ecosystem.config.cjs
eslint.config.mjs
hooks/use-mobile.ts
lib/react-query-provider.tsx
lib/schemas.ts
lib/types.ts
lib/utils.ts
next.config.ts
package.json
postcss.config.mjs
proxy.ts
public/default.png
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
store/useAuthStore.ts
store/useFavoritesStore.ts
store/usePlayerStore.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="app/dashboard/favorites/page.tsx">
'use client';

import { VirtualGrid } from '@/components/virtual-grid';
import { useFavoritesStore } from '@/store/useFavoritesStore';
import { Heart, Loader2 } from 'lucide-react';
import { useSyncExternalStore } from 'react';

export default function FavoritesPage() {
    const favorites = useFavoritesStore((state) => state.favorites);
    const isClient = useSyncExternalStore(
        () => () => {},
        () => true,
        () => false
    );

    if (!isClient) {
         return (
            <div className="flex h-full items-center justify-center">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
         );
    }

    return (
        <div className="h-full flex flex-col">
             <div className="px-4 py-2 border-b border-zinc-800 mb-2 flex items-center gap-4">
                 <Heart className="w-6 h-6 text-red-500 fill-red-500" />
                 <h1 className="text-xl font-semibold text-white">
                    Meus Favoritos <span className="text-zinc-500 text-sm ml-2">({favorites.length})</span>
                 </h1>
             </div>
             
             {favorites.length > 0 ? (
                <VirtualGrid items={favorites} />
             ) : (
                <div className="flex flex-col h-96 items-center justify-center text-zinc-500">
                    <Heart className="w-16 h-16 mb-4 opacity-20" />
                    <p className="text-lg">Você ainda não tem favoritos.</p>
                    <p className="text-sm">Adicione canais, filmes ou séries aos seus favoritos para vê-los aqui.</p>
                </div>
             )}
        </div>
    );
}
</file>

<file path="app/dashboard/layout.tsx">
import { AppSidebar } from '@/components/app-sidebar';
import { SearchInput } from '@/components/search-input';
import { Separator } from '@/components/ui/separator';
import { SidebarInset, SidebarProvider, SidebarTrigger } from '@/components/ui/sidebar';
import { VideoPlayer } from '@/components/video-player';

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset className="bg-zinc-950 overflow-hidden">
        <header className="flex h-16 shrink-0 items-center gap-2 border-b border-zinc-800 transition-[width,height] ease-linear group-has-data-[collapsible=icon]/sidebar-wrapper:h-12 bg-zinc-950/50 backdrop-blur-xl sticky top-0 z-40 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <div className="w-full">
                <SearchInput />
            </div>
        </header>
        <div className="flex-1 p-4 overflow-auto">
            {children}
        </div>
        
        {/* Helper div to verify VideoPlayer z-index fix */}
        <VideoPlayer />
      </SidebarInset>
    </SidebarProvider>
  );
}
</file>

<file path="app/dashboard/live/[categoryId]/page.tsx">
import { ContentLayout } from '@/components/content-layout';

export const dynamic = 'force-dynamic';

interface PageProps {
  params: Promise<{ categoryId: string }>;
}

export default async function LiveCategoryPage({ params }: PageProps) {
  const { categoryId } = await params;
  
  return (
    <ContentLayout 
      action="get_live_streams" 
      categoryId={categoryId}
      title="Canais" 
    />
  );
}
</file>

<file path="app/dashboard/live/all/page.tsx">
import { ContentLayout } from '@/components/content-layout';

export const dynamic = 'force-dynamic';

export default function AllLivePage() {
  return (
    <ContentLayout 
      action="get_live_streams" 
      title="Todos os Canais" 
    />
  );
}
</file>

<file path="app/dashboard/live/page.tsx">
import { LiveCategoryList } from '@/components/category-list';

export const dynamic = 'force-dynamic';

export default function LivePage() {
  return <LiveCategoryList />;
}
</file>

<file path="app/dashboard/loading.tsx">
import { Skeleton } from "@/components/ui/skeleton"

export default function DashboardLoading() {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 p-4">
      {Array.from({ length: 8 }).map((_, i) => (
        <div key={i} className="flex flex-col space-y-3">
          <Skeleton className="h-[200px] w-full rounded-xl bg-zinc-800" />
          <div className="space-y-2">
            <Skeleton className="h-4 w-[250px] bg-zinc-800" />
            <Skeleton className="h-4 w-[200px] bg-zinc-800" />
          </div>
        </div>
      ))}
    </div>
  )
}
</file>

<file path="app/dashboard/movies/[categoryId]/page.tsx">
import { ContentLayout } from '@/components/content-layout';

export const dynamic = 'force-dynamic';

interface PageProps {
  params: Promise<{ categoryId: string }>;
}

export default async function MovieCategoryPage({ params }: PageProps) {
  const { categoryId } = await params;
  
  return (
    <ContentLayout 
      action="get_vod_streams" 
      categoryId={categoryId}
      title="Filmes" 
    />
  );
}
</file>

<file path="app/dashboard/movies/all/page.tsx">
import { ContentLayout } from '@/components/content-layout';

export const dynamic = 'force-dynamic';

export default function AllMoviesPage() {
  return (
    <ContentLayout 
      action="get_vod_streams" 
      title="Todos os Filmes" 
    />
  );
}
</file>

<file path="app/dashboard/movies/page.tsx">
import { MovieCategoryList } from '@/components/category-list';

export const dynamic = 'force-dynamic';

export default function MoviesPage() {
  return <MovieCategoryList />;
}
</file>

<file path="app/dashboard/page.tsx">
import { Clapperboard, Film, Heart, PlayCircle, Sparkles, TrendingUp, Tv } from 'lucide-react';
import Link from 'next/link';

export const dynamic = 'force-dynamic';

export default function DashboardPage() {
  return (
    <div className="flex min-h-full w-full flex-col gap-8 p-6">
      {/* Hero Section */}
      <div className="relative overflow-hidden rounded-3xl border border-zinc-800 bg-linear-to-br from-primary/20 via-zinc-900 to-black p-8 shadow-2xl">
        <div className="relative z-10 mx-auto max-w-2xl text-center">
          <div className="mb-4 inline-flex items-center gap-2 rounded-full border border-primary/30 bg-primary/10 px-4 py-1.5 text-sm font-medium text-primary">
            <Sparkles className="h-4 w-4" />
            Bem-vindo de volta
          </div>
          <h1 className="mb-4 text-5xl font-black tracking-tight text-white md:text-6xl">
            NEXUS <span className="text-primary">IPTV</span>
          </h1>
          <p className="text-lg text-zinc-300">
            Seu player de alta performance para TV ao vivo, filmes e séries.
            <br className="hidden sm:block" />
            Escolha uma categoria ou use os atalhos abaixo para começar.
          </p>
        </div>
        {/* Efeito visual de fundo */}
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(120,119,198,0.1),transparent)]" />
      </div>

      {/* Quick Access Cards */}
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4">
        <QuickAccessCard
          href="/dashboard/live"
          icon={Tv}
          title="Ao Vivo"
          description="Canais em tempo real"
          color="from-blue-500/20 to-blue-600/20"
          borderColor="border-blue-500/30"
        />
        <QuickAccessCard
          href="/dashboard/movies"
          icon={Film}
          title="Filmes"
          description="Catálogo completo VOD"
          color="from-purple-500/20 to-purple-600/20"
          borderColor="border-purple-500/30"
        />
        <QuickAccessCard
          href="/dashboard/series"
          icon={Clapperboard}
          title="Séries"
          description="Episódios e temporadas"
          color="from-pink-500/20 to-pink-600/20"
          borderColor="border-pink-500/30"
        />
        <QuickAccessCard
          href="/dashboard/favorites"
          icon={Heart}
          title="Favoritos"
          description="Seus conteúdos salvos"
          color="from-red-500/20 to-red-600/20"
          borderColor="border-red-500/30"
        />
      </div>

      {/* Stats & Info Grid */}
      <div className="grid grid-cols-1 gap-4 md:grid-cols-3">
        <InfoCard
          icon={PlayCircle}
          title="Reprodução Instantânea"
          description="Clique em qualquer conteúdo para assistir imediatamente no player integrado"
        />
        <InfoCard
          icon={TrendingUp}
          title="Atualizado Constantemente"
          description="Novo conteúdo adicionado diariamente ao catálogo"
        />
        <InfoCard
          icon={Heart}
          title="Gerencie Favoritos"
          description="Salve seus canais e programas favoritos para acesso rápido"
        />
      </div>

     
    </div>
  );
}

function QuickAccessCard({
  href,
  icon: Icon,
  title,
  description,
  color,
  borderColor,
}: {
  href: string;
  icon: React.ElementType;
  title: string;
  description: string;
  color: string;
  borderColor: string;
}) {
  return (
    <Link
      href={href}
      className={`group relative overflow-hidden rounded-2xl border ${borderColor} bg-linear-to-br ${color} p-6 transition-all duration-300 hover:scale-[1.02] hover:shadow-xl`}
    >
      <div className="relative z-10">
        <Icon className="mb-3 h-10 w-10 text-white transition-transform duration-300 group-hover:scale-110" />
        <h3 className="mb-1 text-xl font-bold text-white">{title}</h3>
        <p className="text-sm text-zinc-300">{description}</p>
      </div>
      <div className="absolute inset-0 bg-linear-to-br from-white/5 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100" />
    </Link>
  );
}

function InfoCard({
  icon: Icon,
  title,
  description,
}: {
  icon: React.ElementType;
  title: string;
  description: string;
}) {
  return (
    <div className="rounded-xl border border-zinc-800 bg-zinc-900 p-5 transition-colors hover:border-zinc-700">
      <Icon className="mb-3 h-7 w-7 text-primary" />
      <h3 className="mb-2 font-semibold text-white">{title}</h3>
      <p className="text-sm leading-relaxed text-zinc-400">{description}</p>
    </div>
  );
}
</file>

<file path="app/dashboard/series/[categoryId]/page.tsx">
import { ContentLayout } from '@/components/content-layout';

export const dynamic = 'force-dynamic';

interface PageProps {
  params: Promise<{ categoryId: string }>;
}

export default async function SeriesCategoryPage({ params }: PageProps) {
  const { categoryId } = await params;
  
  return (
    <ContentLayout 
      action="get_series" 
      categoryId={categoryId}
      title="Séries" 
    />
  );
}
</file>

<file path="app/dashboard/series/all/page.tsx">
import { ContentLayout } from '@/components/content-layout';

export const dynamic = 'force-dynamic';

export default function AllSeriesPage() {
  return (
    <ContentLayout 
      action="get_series" 
      title="Todas as Séries" 
    />
  );
}
</file>

<file path="app/dashboard/series/page.tsx">
import { SeriesCategoryList } from '@/components/category-list';

export const dynamic = 'force-dynamic';

export default function SeriesPage() {
  return <SeriesCategoryList />;
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "rtl": false,
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="components/app-sidebar.tsx">
"use client"

import {
  Clapperboard,
  Command,
  Film,
  Heart,
  Home,
  LogOut,
  Tv,
  User
} from "lucide-react"
import * as React from "react"

import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar"
import { useAuthStore } from "@/store/useAuthStore"
import Link from "next/link"
import { usePathname } from "next/navigation"

export function AppSidebar({ ...props }: React.ComponentProps<typeof Sidebar>) {
  const pathname = usePathname();
  const logout = useAuthStore((state) => state.logout);
  const user = useAuthStore((state) => state.username);

  // Memoizar a configuração de navegação para evitar recriação a cada render
  const navMain = React.useMemo(() => [
    {
      title: "Navegação",
      items: [
        {
          title: "Início",
          url: "/dashboard",
          icon: Home,
          isActive: pathname === "/dashboard",
        },
        {
            title: "Ao Vivo",
            url: "/dashboard/live",
            icon: Tv,
            isActive: pathname.startsWith("/dashboard/live"),
        },
        {
            title: "Filmes",
            url: "/dashboard/movies",
            icon: Film,
            isActive: pathname.startsWith("/dashboard/movies"),
        },
        {
            title: "Séries",
            url: "/dashboard/series",
            icon: Clapperboard,
            isActive: pathname.startsWith("/dashboard/series"),
        },
        {
            title: "Favoritos",
            url: "/dashboard/favorites",
            icon: Heart,
            isActive: pathname === "/dashboard/favorites",
        },
      ],
    },
  ], [pathname]);

  return (
    <Sidebar collapsible="icon" {...props} className="border-r border-zinc-800 bg-black text-zinc-400">
      <SidebarHeader>
        <SidebarMenu>
          <SidebarMenuItem>
            <SidebarMenuButton size="lg" asChild className="group-data-[collapsible=icon]:p-2! group-data-[collapsible=icon]:size-8!">
              <Link href="/dashboard" className="group-data-[collapsible=icon]:flex group-data-[collapsible=icon]:items-center group-data-[collapsible=icon]:justify-center">
                <div className="flex aspect-square size-8 items-center justify-center rounded-lg bg-primary text-primary-foreground">
                  <Command className="size-4" />
                </div>
                <div className="grid flex-1 text-left text-sm leading-tight group-data-[collapsible=icon]:hidden">
                  <span className="truncate font-semibold text-white">Nexus IPTV</span>
                  <span className="truncate text-xs">Premium Player</span>
                </div>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarHeader>
      <SidebarContent>
        {navMain.map((group) => (
          <SidebarGroup key={group.title}>
            <SidebarGroupLabel>{group.title}</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu>
                {group.items.map((item) => (
                  <SidebarMenuItem key={item.title}>
                    <SidebarMenuButton asChild isActive={item.isActive} tooltip={item.title}>
                      <Link href={item.url}>
                        <item.icon />
                        <span>{item.title}</span>
                      </Link>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                ))}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        ))}
      </SidebarContent>
      <SidebarFooter>
        <SidebarMenu>
          <SidebarMenuItem>
            <SidebarMenuButton 
              size="lg" 
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground group-data-[collapsible=icon]:p-2! group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:flex group-data-[collapsible=icon]:items-center group-data-[collapsible=icon]:justify-center"
            >
              <div className="flex aspect-square size-8 items-center justify-center rounded-lg bg-zinc-800 text-zinc-400">
                <User className="size-4" />
              </div>
              <div className="grid flex-1 text-left text-sm leading-tight group-data-[collapsible=icon]:hidden">
                <span className="truncate font-semibold text-white">{user || 'Usuário'}</span>
                <span className="truncate text-xs">Conectado</span>
              </div>
              <LogOut className="ml-auto size-4 group-data-[collapsible=icon]:hidden cursor-pointer hover:text-white transition-colors" onClick={logout}/>
            </SidebarMenuButton>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarFooter>
    </Sidebar>
  )
}
</file>

<file path="components/channel-card.tsx">
'use client';

import { Card, CardContent } from '@/components/ui/card';
import { Channel } from '@/lib/types';
import { useAuthStore } from '@/store/useAuthStore';
import { usePlayerStore } from '@/store/usePlayerStore';
import { Play } from 'lucide-react';
import Image from 'next/image';
import { memo, useCallback, useEffect, useState } from 'react';

interface ChannelCardProps {
    item: Channel;
    onClick?: (item: Channel) => void;
}

export const ChannelCard = memo(function ChannelCard({ item, onClick }: ChannelCardProps) {
    const playChannel = usePlayerStore((state) => state.playChannel);
    const username = useAuthStore((state) => state.username);
    const password = useAuthStore((state) => state.password);
    
    const [imgSrc, setImgSrc] = useState(item.logo || '/default.jpg');
    const [imgError, setImgError] = useState(false);

    // Usar useEffect para atualizar a imagem quando o item mudar
    useEffect(() => {
         // eslint-disable-next-line react-hooks/set-state-in-effect
        setImgSrc(item.logo || '/default.jpg');
        setImgError(false);
    }, [item.logo]);

    const handlePlay = useCallback(() => {
        if (onClick) {
            onClick(item);
            return;
        }

        if (!username || !password) {
            alert("Credenciais não encontradas.");
            return;
        }
        
        let streamUrl = '';
        if (item.stream_type === 'movie') {
            const ext = item.extension || 'mp4';
            streamUrl = `/api/nexus/movie/${username}/${password}/${item.id}.${ext}`;
        } else if (item.stream_type === 'series') {
             const ext = item.extension || 'mp4';
             streamUrl = `/api/nexus/series/${username}/${password}/${item.id}.${ext}`;
        } else {
            streamUrl = `/api/nexus/live/${username}/${password}/${item.id}.m3u8`;
        }

        playChannel(streamUrl, item.name);
    }, [username, password, item, playChannel, onClick]);

    const handleImageError = useCallback(() => {
        if (!imgError) {
            setImgError(true);
            setImgSrc('/default.png');
        }
    }, [imgError]);

    return (
        <Card 
            className="group relative overflow-hidden bg-zinc-900 border-zinc-800 cursor-pointer hover:ring-2 hover:ring-primary transition-all h-full"
            onClick={handlePlay}
        >
            <CardContent className="p-0 relative h-full">
                {/* Container com aspect ratio para poster (2:3) */}
                <div className="relative w-full h-full">
                    <div className="absolute inset-0 bg-zinc-950 flex items-center justify-center text-zinc-700">
                        <Play className="opacity-20 w-10 h-10" />
                    </div>
                    
                    <Image
                        src={imgSrc}
                        alt={item.name}
                        fill
                        sizes="(max-width: 640px) 33vw, (max-width: 768px) 25vw, (max-width: 1024px) 20vw, 16vw"
                        className="object-cover group-hover:scale-105 transition-transform duration-300"
                        unoptimized
                        onError={handleImageError}
                    />
                    
                    <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                        <Play className="text-white fill-white w-10 h-10 drop-shadow-lg" />
                    </div>

                    <div className="absolute bottom-0 left-0 right-0 p-2 bg-linear-to-t from-black via-black/80 to-transparent pt-6">
                        <p className="text-white text-xs font-medium line-clamp-2 leading-tight">{item.name}</p>
                    </div>
                </div>
            </CardContent>
        </Card>
    );
});
</file>

<file path="components/search-input.tsx">
'use client';

import { Input } from '@/components/ui/input';
import { Search } from 'lucide-react';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { Suspense, useCallback, useEffect, useRef, useState } from 'react';

function SearchInputInner() {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  // Usar ref para valores que não devem triggerar re-render
  const routerRef = useRef(router);
  const pathnameRef = useRef(pathname);
  
  // Atualizar refs quando mudam
  useEffect(() => {
    routerRef.current = router;
    pathnameRef.current = pathname;
  }, [router, pathname]);
  
  // Initialize from URL only once
  const initialQuery = searchParams.get('q') || '';
  const [term, setTerm] = useState(initialQuery);
  const isFirstRender = useRef(true);

  // Debounced search - only update URL after user stops typing
  useEffect(() => {
    // Não atualizar na primeira renderização
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    const timeoutId = setTimeout(() => {
      const params = new URLSearchParams();
      if (term) {
        params.set('q', term);
      }
      const queryString = params.toString();
      const newUrl = queryString ? `${pathnameRef.current}?${queryString}` : pathnameRef.current;
      routerRef.current.replace(newUrl, { scroll: false });
    }, 300);

    return () => clearTimeout(timeoutId);
  }, [term]);

  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setTerm(e.target.value);
  }, []);

  return (
    <div className="relative max-w-md w-full">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-zinc-500" />
      <Input
        placeholder="Buscar canais, filmes..."
        value={term}
        onChange={handleChange}
        className="pl-10 bg-zinc-900 border-zinc-800 text-white placeholder:text-zinc-500"
      />
    </div>
  );
}

// Wrap in Suspense to prevent hydration issues with useSearchParams
export function SearchInput() {
  return (
    <Suspense fallback={
      <div className="relative max-w-md w-full">
        <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-zinc-500" />
        <Input
          placeholder="Buscar canais, filmes..."
          disabled
          className="pl-10 bg-zinc-900 border-zinc-800 text-white placeholder:text-zinc-500"
        />
      </div>
    }>
      <SearchInputInner />
    </Suspense>
  );
}
</file>

<file path="components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import * as React from "react"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle }
</file>

<file path="components/ui/dialog.tsx">
"use client"

import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-zinc-800 bg-zinc-950 p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 z-50 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-zinc-800 data-[state=open]:text-white hover:bg-zinc-800 p-1">
        <X className="h-4 w-4 text-white" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight text-white",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-zinc-400", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
    Dialog, DialogClose,
    DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogOverlay, DialogPortal, DialogTitle, DialogTrigger
}
</file>

<file path="components/ui/form.tsx">
"use client"

import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import * as React from "react"
import {
    Controller,
    ControllerProps,
    FieldPath,
    FieldValues,
    FormProvider,
    useFormContext,
} from "react-hook-form"

import { Label } from "@/components/ui/label"
import { cn } from "@/lib/utils"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    />
  )
})
FormMessage.displayName = "FormMessage"

export {
    Form, FormControl,
    FormDescription, FormField, FormItem,
    FormLabel, FormMessage, useFormField
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="components/ui/label.tsx">
"use client"

import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"
import * as React from "react"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="components/ui/separator.tsx">
"use client"

import * as SeparatorPrimitive from "@radix-ui/react-separator"
import * as React from "react"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = "horizontal", ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative
    orientation={orientation}
    className={cn(
      "shrink-0 bg-border",
      orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
      className
    )}
    {...props}
  />
))
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="components/ui/sheet.tsx">
"use client"

import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
    Sheet, SheetClose,
    SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger
}
</file>

<file path="components/ui/sidebar.tsx">
"use client"

import { Slot } from "@radix-ui/react-slot"
import { PanelLeft } from "lucide-react"
import * as React from "react"

import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
    Tooltip,
    TooltipContent,
    TooltipProvider,
    TooltipTrigger,
} from "@/components/ui/tooltip"
import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider")
  }
  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }
        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[var(--sidebar-width)] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[var(--sidebar-width)] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[var(--sidebar-width)] bg-transparent transition-all ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[var(--sidebar-width)] transition-all ease-linear md:flex",
            side === "left"
              ? "left-0 border-r"
              : "right-0 border-l",
            // If use floating, the sidebar is floating
             variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+_2px)]"
              : "group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
})
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => {
  return (
    <ul
      ref={ref}
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
})
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => {
  return (
    <li
      ref={ref}
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
})
SidebarMenuItem.displayName = "SidebarMenuItem"

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
    variant?: "default" | "outline" | "ghost" | "secondary"
    size?: "default" | "sm" | "lg"
  }
>(
  (
    {
      asChild = false,
      isActive = false,
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(
          "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
          "text-sidebar-foreground",
          className
        )}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean; showOnHover?: boolean }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="menu-badge"
      className={cn(
        "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { showIcon?: boolean }
>(({ className, showIcon = false, ...props }, ref) => {
  // Use a fixed width or just percentage for consistent rendering
  const width = React.useMemo(() => {
    return '70%'
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => {
  return (
    <ul
      ref={ref}
      data-sidebar="menu-sub"
      className={cn(
        "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(
  (
    { asChild = false, size = "md", isActive, className, ...props },
    ref
  ) => {
    const Comp = asChild ? Slot : "a"

    return (
      <Comp
        ref={ref}
        data-sidebar="menu-sub-button"
        data-size={size}
        data-active={isActive}
        className={cn(
          "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
          "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
          size === "sm" && "text-xs",
          size === "md" && "text-sm",
          className
        )}
        {...props}
      />
    )
  }
)
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
    Sidebar,
    SidebarContent,
    SidebarFooter,
    SidebarGroup,
    SidebarGroupAction,
    SidebarGroupContent,
    SidebarGroupLabel,
    SidebarHeader,
    SidebarInput,
    SidebarInset,
    SidebarMenu,
    SidebarMenuAction,
    SidebarMenuBadge,
    SidebarMenuButton,
    SidebarMenuItem,
    SidebarMenuSkeleton,
    SidebarMenuSub,
    SidebarMenuSubButton,
    SidebarMenuSubItem,
    SidebarProvider,
    SidebarRail,
    SidebarSeparator,
    SidebarTrigger,
    useSidebar
}
</file>

<file path="components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="components/ui/tooltip.tsx">
"use client"

import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import * as React from "react"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger }
</file>

<file path="components/video-player.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { usePlayerStore } from '@/store/usePlayerStore';
import Hls from 'hls.js';
import {
  ArrowLeft,
  Loader2,
  Maximize,
  Maximize2,
  Minimize2,
  Pause,
  PictureInPicture2,
  Play,
  Volume2,
  VolumeX,
  X
} from 'lucide-react';
import { useCallback, useEffect, useRef, useState } from 'react';

export function VideoPlayer() {
  const { isPlaying, streamUrl, streamTitle, closePlayer } = usePlayerStore();
  const [isMinimized, setIsMinimized] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [showControls, setShowControls] = useState(true);
  const [volume, setVolume] = useState(1);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [, setIsFullscreen] = useState(false);
  
  const videoRef = useRef<HTMLVideoElement>(null);
  const hlsRef = useRef<Hls | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const hideControlsTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Auto-hide controls after 3 seconds of inactivity
  const resetControlsTimeout = useCallback(() => {
    setShowControls(true);
    if (hideControlsTimeoutRef.current) {
      clearTimeout(hideControlsTimeoutRef.current);
    }
    hideControlsTimeoutRef.current = setTimeout(() => {
      if (!isPaused) {
        setShowControls(false);
      }
    }, 3000);
  }, [isPaused]);

  // Initialize HLS player
  useEffect(() => {
    if (!streamUrl || !videoRef.current) return;

    const video = videoRef.current;
    
    const initializePlayer = () => {
      setIsLoading(true);
      setHasError(false);
      setIsPaused(false);
    };
    
    queueMicrotask(initializePlayer);

    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }

    const isM3U8 = streamUrl.toLowerCase().includes('.m3u8');

    if (isM3U8 && Hls.isSupported()) {
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 90,
      });

      hlsRef.current = hls;
      hls.loadSource(streamUrl);
      hls.attachMedia(video);

      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        setIsLoading(false);
        video.play().catch(console.error);
      });

      hls.on(Hls.Events.ERROR, (_, data) => {
        if (data.fatal) {
          console.error('HLS Fatal Error:', data);
          setHasError(true);
          setIsLoading(false);
          
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              hls.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              hls.recoverMediaError();
              break;
            default:
              break;
          }
        }
      });
    } else {
      // Native playback for non-HLS or Safari HLS
      video.src = streamUrl;
      video.addEventListener('loadedmetadata', () => {
        setIsLoading(false);
        video.play().catch(console.error);
      });
      video.addEventListener('error', (e) => {
          console.error("Video Error:", e);
          setHasError(true);
          setIsLoading(false);
      });
    }

    return () => {
      if (hlsRef.current) {
        hlsRef.current.destroy();
        hlsRef.current = null;
      }
    };
  }, [streamUrl]);

  // Update time display
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime);
      setDuration(video.duration || 0);
    };

    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('loadedmetadata', handleTimeUpdate);

    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('loadedmetadata', handleTimeUpdate);
    };
  }, []);

  // Fullscreen change listener
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, []);

  const handlePlayPause = useCallback(() => {
    if (!videoRef.current) return;
    if (videoRef.current.paused) {
      videoRef.current.play();
      setIsPaused(false);
    } else {
      videoRef.current.pause();
      setIsPaused(true);
    }
    resetControlsTimeout();
  }, [resetControlsTimeout]);

  const handleMuteToggle = useCallback(() => {
    if (!videoRef.current) return;
    videoRef.current.muted = !videoRef.current.muted;
    setIsMuted(!isMuted);
  }, [isMuted]);

  const handleVolumeChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    if (videoRef.current) {
      videoRef.current.volume = newVolume;
      setVolume(newVolume);
      setIsMuted(newVolume === 0);
    }
  }, []);

  const handleSeek = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const time = parseFloat(e.target.value);
    if (videoRef.current) {
      videoRef.current.currentTime = time;
      setCurrentTime(time);
    }
  }, []);

  const handleFullscreen = useCallback(async () => {
    if (!containerRef.current) return;
    
    if (document.fullscreenElement) {
      await document.exitFullscreen();
    } else {
      await containerRef.current.requestFullscreen();
    }
  }, []);

  const handlePiP = useCallback(async () => {
    if (!videoRef.current) return;
    
    try {
      if (document.pictureInPictureElement) {
        await document.exitPictureInPicture();
      } else {
        await videoRef.current.requestPictureInPicture();
      }
    } catch (err) {
      console.error('PiP error:', err);
    }
  }, []);

  const handleClose = useCallback(() => {
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }
    closePlayer();
  }, [closePlayer]);

  const formatTime = (seconds: number) => {
    if (!isFinite(seconds)) return '--:--';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  if (!isPlaying || !streamUrl) return null;

  return (
    <div 
      ref={containerRef}
      className={cn(
        "fixed transition-all duration-300 z-100 bg-black shadow-2xl overflow-hidden",
        isMinimized 
            ? "bottom-4 right-4 w-96 h-56 rounded-xl border border-zinc-800" 
            : "inset-0 w-full h-full"
      )}
      onMouseMove={resetControlsTimeout}
      onMouseEnter={() => setShowControls(true)}
    >
        {/* Video Element */}
        <video 
          ref={videoRef}
          className="w-full h-full object-contain bg-black cursor-pointer"
          playsInline
          autoPlay
          onClick={handlePlayPause}
        />

        {/* Loading Overlay */}
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/80 z-20">
            <Loader2 className="w-12 h-12 text-primary animate-spin" />
            <span className="ml-3 text-white">Carregando stream...</span>
          </div>
        )}

        {/* Error Overlay */}
        {hasError && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-20">
            <p className="text-red-500 text-lg mb-4">Erro ao carregar o stream</p>
            <Button variant="outline" onClick={handleClose}>Fechar</Button>
          </div>
        )}

        {/* Top Bar - Always visible with fade */}
        <div className={cn(
          "absolute top-0 left-0 right-0 z-10 p-4 flex justify-between items-center bg-linear-to-b from-black/90 via-black/50 to-transparent transition-opacity duration-300",
          showControls || isMinimized ? "opacity-100" : "opacity-0 pointer-events-none"
        )}>
            <div className="flex items-center gap-3">
              <Button 
                variant="ghost" 
                size="icon" 
                className="text-white hover:bg-white/20"
                onClick={handleClose}
              >
                <ArrowLeft className="w-5 h-5" />
              </Button>
              <h3 className="text-white font-medium truncate max-w-[50vw]">{streamTitle}</h3>
            </div>
            <div className="flex gap-2">
                <Button 
                    variant="ghost" 
                    size="icon" 
                    className="text-white hover:bg-white/20"
                    onClick={() => setIsMinimized(!isMinimized)}
                >
                    {isMinimized ? <Maximize2 className="w-5 h-5" /> : <Minimize2 className="w-5 h-5" />}
                </Button>
                <Button 
                    variant="ghost" 
                    size="icon" 
                    className="text-white hover:bg-red-500/20 hover:text-red-500"
                    onClick={handleClose}
                >
                    <X className="w-5 h-5" />
                </Button>
            </div>
        </div>

        {/* Center Play/Pause Button (appears when paused or loading) */}
        {isPaused && !isLoading && (
          <div 
            className="absolute inset-0 flex items-center justify-center cursor-pointer z-10"
            onClick={handlePlayPause}
          >
            <div className="w-20 h-20 rounded-full bg-black/60 flex items-center justify-center hover:bg-black/80 transition-colors">
              <Play className="w-10 h-10 text-white fill-white ml-1" />
            </div>
          </div>
        )}

        {/* Bottom Controls Bar */}
        <div className={cn(
          "absolute bottom-0 left-0 right-0 z-10 bg-linear-to-t from-black/90 via-black/50 to-transparent transition-opacity duration-300",
          showControls || isMinimized ? "opacity-100" : "opacity-0 pointer-events-none",
          isMinimized ? "p-2" : "p-4"
        )}>
          {/* Progress Bar (only for VOD, not live) */}
          {duration > 0 && duration !== Infinity && !isMinimized && (
            <div className="mb-3 px-2">
              <input
                type="range"
                min={0}
                max={duration}
                value={currentTime}
                onChange={handleSeek}
                className="w-full h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-primary"
              />
              <div className="flex justify-between text-xs text-zinc-400 mt-1">
                <span>{formatTime(currentTime)}</span>
                <span>{formatTime(duration)}</span>
              </div>
            </div>
          )}

          {/* Live indicator */}
          {(duration === Infinity || duration === 0) && !isMinimized && (
            <div className="mb-2 px-2">
              <span className="inline-flex items-center gap-1 text-xs text-red-500 font-medium">
                <span className="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
                AO VIVO
              </span>
            </div>
          )}

          {/* Controls Row */}
          <div className="flex items-center justify-between gap-2 px-2">
            <div className="flex items-center gap-1">
              {/* Play/Pause */}
              <Button 
                variant="ghost" 
                size="icon" 
                className="text-white hover:bg-white/20 h-10 w-10"
                onClick={handlePlayPause}
              >
                {isPaused ? <Play className="w-5 h-5 fill-white" /> : <Pause className="w-5 h-5" />}
              </Button>

              {/* Volume */}
              <Button 
                variant="ghost" 
                size="icon" 
                className="text-white hover:bg-white/20 h-10 w-10"
                onClick={handleMuteToggle}
              >
                {isMuted || volume === 0 ? <VolumeX className="w-5 h-5" /> : <Volume2 className="w-5 h-5" />}
              </Button>

              {/* Volume Slider (hide on minimized) */}
              {!isMinimized && (
                <input
                  type="range"
                  min={0}
                  max={1}
                  step={0.1}
                  value={isMuted ? 0 : volume}
                  onChange={handleVolumeChange}
                  className="w-20 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-white"
                />
              )}
            </div>

            {/* Right side controls */}
            {!isMinimized && (
              <div className="flex items-center gap-1">
                {/* Picture in Picture */}
                <Button 
                  variant="ghost" 
                  size="icon" 
                  className="text-white hover:bg-white/20 h-10 w-10"
                  onClick={handlePiP}
                >
                  <PictureInPicture2 className="w-5 h-5" />
                </Button>

                {/* Fullscreen */}
                <Button 
                  variant="ghost" 
                  size="icon" 
                  className="text-white hover:bg-white/20 h-10 w-10"
                  onClick={handleFullscreen}
                >
                  <Maximize className="w-5 h-5" />
                </Button>
              </div>
            )}
          </div>
        </div>
    </div>
  );
}
</file>

<file path="components/virtual-grid.tsx">
'use client';

import { ChannelCard } from '@/components/channel-card';
import { ContentInfoDialog } from '@/components/content-info-dialog';
import { Button } from '@/components/ui/button';
import { Channel } from '@/lib/types';
import { useVirtualizer } from '@tanstack/react-virtual';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';
import { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';

interface VirtualGridProps {
  items: Channel[];
  itemsPerPage?: number;
}

const ITEMS_PER_PAGE = 60; // 60 itens por página (padrão)

// Número de colunas baseado no breakpoint
const getColumns = (width: number) => {
  if (width >= 1280) return 6; // xl
  if (width >= 1024) return 5; // lg
  if (width >= 768) return 4;  // md
  if (width >= 640) return 3;  // sm
  return 2;
};

const getRowHeight = (containerWidth: number, columns: number, gap: number = 16) => {
  const totalGap = gap * (columns - 1);
  const padding = 16;
  const cardWidth = (containerWidth - totalGap - padding) / columns;
  const cardHeight = cardWidth * 1.5;
  return cardHeight + 16;
};

export const VirtualGrid = memo(function VirtualGrid({ items, itemsPerPage = ITEMS_PER_PAGE }: VirtualGridProps) {
  const parentRef = useRef<HTMLDivElement>(null);
  const [selectedItem, setSelectedItem] = useState<Channel | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [columns, setColumns] = useState(4);
  const [containerWidth, setContainerWidth] = useState(800);
  const [currentPage, setCurrentPage] = useState(1);

  // Calcular total de páginas e itens paginados
  const totalPages = useMemo(() => Math.ceil(items.length / itemsPerPage), [items.length, itemsPerPage]);
  
  const paginatedItems = useMemo(() => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    return items.slice(startIndex, startIndex + itemsPerPage);
  }, [items, currentPage, itemsPerPage]);

  // Reset para página 1 quando os items mudam (nova busca/categoria)
  useEffect(() => {
    setCurrentPage(1);
  }, [items]);

  // Observar mudanças de tamanho do container
  useEffect(() => {
    if (!parentRef.current) return;

    const updateSize = (width: number) => {
      const newColumns = getColumns(width);
      setColumns((prev) => (prev !== newColumns ? newColumns : prev));
      setContainerWidth((prev) => (prev !== width ? width : prev));
    };

    const resizeObserver = new ResizeObserver((entries) => {
      const entry = entries[0];
      if (entry) {
        updateSize(entry.contentRect.width);
      }
    });

    resizeObserver.observe(parentRef.current);
    updateSize(parentRef.current.clientWidth);

    return () => resizeObserver.disconnect();
  }, []);

  const rowCount = useMemo(() => Math.ceil(paginatedItems.length / columns), [paginatedItems.length, columns]);
  
  const estimatedRowHeight = useMemo(() => 
    getRowHeight(containerWidth, columns), 
    [containerWidth, columns]
  );

    // eslint-disable-next-line react-hooks/incompatible-library
  const rowVirtualizer = useVirtualizer({
    count: rowCount,
    getScrollElement: () => parentRef.current,
    estimateSize: () => estimatedRowHeight,
    overscan: 2,
  });

  const virtualItems = rowVirtualizer.getVirtualItems();

  const handleItemClick = useCallback((item: Channel) => {
      setSelectedItem(item);
      setDialogOpen(true);
  }, []);

  const handleDialogChange = useCallback((open: boolean) => {
    setDialogOpen(open);
    if (!open) {
      setTimeout(() => setSelectedItem(null), 150);
    }
  }, []);

  // Funções de navegação de página
  const goToPage = useCallback((page: number) => {
    setCurrentPage(page);
    // Scroll para o topo ao mudar de página
    parentRef.current?.scrollTo({ top: 0, behavior: 'smooth' });
  }, []);

  const goToFirstPage = useCallback(() => goToPage(1), [goToPage]);
  const goToLastPage = useCallback(() => goToPage(totalPages), [goToPage, totalPages]);
  const goToPrevPage = useCallback(() => goToPage(Math.max(1, currentPage - 1)), [goToPage, currentPage]);
  const goToNextPage = useCallback(() => goToPage(Math.min(totalPages, currentPage + 1)), [goToPage, currentPage, totalPages]);

  // Gerar números de páginas para exibir (max 5)
  const pageNumbers = useMemo(() => {
    const pages: number[] = [];
    const maxVisible = 5;
    let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
    const end = Math.min(totalPages, start + maxVisible - 1);
    
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }
    
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    return pages;
  }, [currentPage, totalPages]);

  // Não mostrar paginação se houver apenas 1 página
  const showPagination = totalPages > 1;

  return (
    <>
        <div
          ref={parentRef}
          className="flex-1 min-h-0 w-full overflow-auto"
        >
          <div
            style={{
              height: `${rowVirtualizer.getTotalSize()}px`,
              width: '100%',
              position: 'relative',
            }}
          >
            {virtualItems.map((virtualRow) => {
              const startIndex = virtualRow.index * columns;
              const rowItems = paginatedItems.slice(startIndex, startIndex + columns);

              return (
                <div
                  key={virtualRow.key}
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${virtualRow.start}px)`,
                    display: 'grid',
                    gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,
                    gap: '16px',
                    padding: '8px',
                  }}
                >
                  {rowItems.map((item) => (
                    <ChannelCard key={item.id} item={item} onClick={handleItemClick} />
                  ))}
                </div>
              );
            })}
          </div>
        </div>
        
        {/* Barra de Paginação */}
        {showPagination && (
          <div className="flex items-center justify-center gap-1 py-3 px-4 border-t border-zinc-800 bg-zinc-900/50">
            <Button
              variant="ghost"
              size="icon"
              onClick={goToFirstPage}
              disabled={currentPage === 1}
              className="h-8 w-8 text-zinc-400 hover:text-white disabled:opacity-30"
            >
              <ChevronsLeft className="h-4 w-4" />
            </Button>
            <Button
              variant="ghost"
              size="icon"
              onClick={goToPrevPage}
              disabled={currentPage === 1}
              className="h-8 w-8 text-zinc-400 hover:text-white disabled:opacity-30"
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            
            <div className="flex items-center gap-1 mx-2">
              {pageNumbers.map((page) => (
                <Button
                  key={page}
                  variant={page === currentPage ? "default" : "ghost"}
                  size="sm"
                  onClick={() => goToPage(page)}
                  className={`h-8 w-8 p-0 ${
                    page === currentPage 
                      ? 'bg-primary text-primary-foreground' 
                      : 'text-zinc-400 hover:text-white'
                  }`}
                >
                  {page}
                </Button>
              ))}
            </div>
            
            <Button
              variant="ghost"
              size="icon"
              onClick={goToNextPage}
              disabled={currentPage === totalPages}
              className="h-8 w-8 text-zinc-400 hover:text-white disabled:opacity-30"
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
            <Button
              variant="ghost"
              size="icon"
              onClick={goToLastPage}
              disabled={currentPage === totalPages}
              className="h-8 w-8 text-zinc-400 hover:text-white disabled:opacity-30"
            >
              <ChevronsRight className="h-4 w-4" />
            </Button>
            
            <span className="ml-4 text-xs text-zinc-500">
              {(currentPage - 1) * itemsPerPage + 1}-{Math.min(currentPage * itemsPerPage, items.length)} de {items.length}
            </span>
          </div>
        )}
        
        <ContentInfoDialog 
            item={selectedItem} 
            open={dialogOpen} 
            onOpenChange={handleDialogChange} 
        />
    </>
  );
});
</file>

<file path="ecosystem.config.cjs">
module.exports = {
  apps: [
    {
      name: "nexus-iptv",
      script: "node_modules/next/dist/bin/next",
      args: "start",
      cwd: "/var/www/nexus-iptv",
      instances: 1,
      exec_mode: "fork",
      autorestart: true,
      watch: false,
      max_memory_restart: "1G",
      env: {
        NODE_ENV: "production",
        PORT: 3005
      },
      error_file: "/var/logs/nexus-iptv/pm2-error.log",
      out_file: "/var/logs/nexus-iptv/pm2-out.log",
      log_date_format: "YYYY-MM-DD HH:mm:ss Z",
      merge_logs: true,
      time: true
    }
  ]
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="hooks/use-mobile.ts">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="lib/react-query-provider.tsx">
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';

export function ReactQueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 1000 * 60 * 5, // 5 minutes
        refetchOnWindowFocus: false,
      },
    },
  }));

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
</file>

<file path="lib/schemas.ts">
import { z } from "zod";

export const LoginSchema = z.object({
  dns: z.string().url({ message: "URL do servidor inválida" }),
  username: z.string().min(1, { message: "Usuário é obrigatório" }),
  password: z.string().min(1, { message: "Senha é obrigatória" }),
  remember: z.boolean().default(false),
});

export type LoginFormData = z.infer<typeof LoginSchema>;
</file>

<file path="lib/types.ts">
export interface XtreamLoginResponse {
  user_info: {
    username: string;
    password: string;
    message: string;
    auth: number;
    status: string;
    exp_date: string;
    is_trial: string;
    active_cons: string;
    created_at: string;
    max_connections: string;
    allowed_output_formats: string[];
  };
  server_info: {
    url: string;
    port: string;
    https_port: string;
    server_protocol: string;
    rtmp_port: string;
    timezone: string;
    timestamp_now: number;
    time_now: string;
  };
}

export interface XtreamCategory {
  category_id: string;
  category_name: string;
  parent_id: number;
}

export interface XtreamStream {
  num: number;
  name: string;
  stream_type: string;
  stream_id: number;
  stream_icon: string;
  epg_channel_id: string;
  added: string;
  category_id: string;
  custom_sid: string;
  tv_archive: number;
  direct_source: string;
  tv_archive_duration: number;
  container_extension?: string;
}

export interface XtreamSeries {
  series_id: number;
  name: string;
  cover: string;
  category_id: string;
  plot?: string;
  cast?: string;
  director?: string;
  genre?: string;
  releaseDate?: string;
  last_modified?: string;
  rating?: string;
}

export interface XtreamEpisode {
  id: string;
  episode_num: string | number;
  title: string;
  container_extension?: string;
  info?: {
    movie_image?: string;
    plot?: string;
    duration?: string;
    rating?: string;
  };
  custom_sid?: string;
  added?: string;
  season?: number;
  direct_source?: string;
}

export interface XtreamSeason {
  air_date: string;
  episode_count: number;
  id: number;
  name: string;
  overview: string;
  season_number: number;
  cover: string;
  cover_big: string;
}

export interface XtreamSeriesInfo {
  seasons: XtreamSeason[];
  episodes: { [key: string]: XtreamEpisode[] };
  info: {
    name: string;
    cover: string;
    plot: string;
    cast: string;
    director: string;
    genre: string;
    releaseDate: string;
    last_modified: string;
    rating: string;
    rating_5based: number;
    backdrop_path: string[];
    youtube_trailer: string;
    episode_run_time: string;
    category_id: string;
  };
}

export interface XtreamVodInfo {
  info: {
    name: string;
    o_name?: string;
    cover_big?: string;
    movie_image?: string;
    releasedate?: string;
    episode_run_time?: string;
    youtube_trailer?: string;
    director?: string;
    actors?: string;
    cast?: string;
    description?: string;
    plot?: string;
    age?: string;
    rating?: string;
    rating_5based?: number;
    country?: string;
    genre?: string;
    duration?: string;
    video?: {
      duration_secs?: number;
      duration?: string;
    };
    audio?: {
      bitrate?: string;
      channels?: number;
    };
    bitrate?: number;
  };
  movie_data?: {
    stream_id: number;
    name: string;
    added: string;
    category_id: string;
    container_extension: string;
    custom_sid: string;
    direct_source: string;
  };
}

export interface XtreamEpgListing {
  id: string;
  epg_id: string;
  title: string;
  lang: string;
  start: string;
  end: string;
  description: string;
  channel_id: string;
  start_timestamp: string | number;
  stop_timestamp: string | number;
}

export interface XtreamEpgShortResponse {
  epg_listings: XtreamEpgListing[];
}

// Optimized Types for Client
export interface Category {
  id: string;
  name: string;
}

export interface Channel {
  id: number;
  name: string;
  logo: string;
  group_id: string;
  url?: string; // Constructed client-side or server-side
  stream_type?: 'live' | 'movie' | 'series';
  extension?: string;
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="proxy.ts">
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';

export function proxy(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/api/nexus')) {
    const dns = request.cookies.get('nexus_dns')?.value;

    if (!dns) {
      return NextResponse.json(
        { error: 'DNS not configured', details: 'Please login first' },
        { status: 401 }
      );
    }

    const path = request.nextUrl.pathname.replace('/api/nexus', '');
    const searchParams = request.nextUrl.search;
    const targetUrl = `${dns}${path}${searchParams}`;
    const requestHeaders = new Headers(request.headers);
    requestHeaders.set('Host', new URL(dns).host);

    return NextResponse.rewrite(new URL(targetUrl));
  }
}

export const config = {
  matcher: '/api/nexus/:path*',
};
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="store/useAuthStore.ts">
import Cookies from 'js-cookie';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';

interface AuthState {
  dns: string | null;
  username: string | null;
  password: string | null;
  isAuthenticated: boolean;
  setCredentials: (dns: string, username: string, password: string) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      dns: null,
      username: null,
      password: null,
      isAuthenticated: false,
      setCredentials: (dns, username, password) => {
        // Sync to cookies for Middleware access
        Cookies.set('nexus_dns', dns, { expires: 365 });
        Cookies.set('nexus_username', username, { expires: 365 });
        Cookies.set('nexus_password', password, { expires: 365 });
        
        set({ dns, username, password, isAuthenticated: true });
      },
      logout: () => {
        Cookies.remove('nexus_dns');
        Cookies.remove('nexus_username');
        Cookies.remove('nexus_password');
        set({ dns: null, username: null, password: null, isAuthenticated: false });
      },
    }),
    {
      name: 'nexus-auth-storage',
      storage: createJSONStorage(() => localStorage),
    }
  )
);
</file>

<file path="store/useFavoritesStore.ts">
import { Channel } from '@/lib/types';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';

interface FavoritesState {
  favorites: Channel[];
  addFavorite: (channel: Channel) => void;
  removeFavorite: (id: number) => void;
  toggleFavorite: (channel: Channel) => void;
}

export const useFavoritesStore = create<FavoritesState>()(
  persist(
    (set, get) => ({
      favorites: [],
      addFavorite: (channel) => set((state) => {
        if (state.favorites.some(f => f.id === channel.id)) return state;
        return { favorites: [...state.favorites, channel] };
      }),
      removeFavorite: (id) => set((state) => ({ favorites: state.favorites.filter((fav) => fav.id !== id) })),
      toggleFavorite: (channel) => {
        const { favorites } = get();
        const exists = favorites.some(f => f.id === channel.id);
        
        if (exists) {
            set({ favorites: favorites.filter((fav) => fav.id !== channel.id) });
        } else {
            set({ favorites: [...favorites, channel] });
        }
      },
    }),
    {
      name: 'nexus-favorites',
      storage: createJSONStorage(() => localStorage),
    }
  )
);

// Helper hook para verificar se um item é favorito sem causar re-renders desnecessários
export function useIsFavorite(id: number): boolean {
  return useFavoritesStore((state) => state.favorites.some((fav) => fav.id === id));
}
</file>

<file path="store/usePlayerStore.ts">
import { create } from 'zustand';

interface PlayerState {
  isPlaying: boolean;
  streamUrl: string | null;
  streamTitle: string | null;
  isMuted: boolean;
  volume: number;
  setPlaying: (isPlaying: boolean) => void;
  playChannel: (url: string, title: string) => void;
  closePlayer: () => void;
  setMuted: (isMuted: boolean) => void;
  setVolume: (volume: number) => void;
}

export const usePlayerStore = create<PlayerState>((set) => ({
  isPlaying: false,
  streamUrl: null,
  streamTitle: null,
  isMuted: false,
  volume: 1,
  setPlaying: (isPlaying) => set({ isPlaying }),
  playChannel: (url, title) => set({ isPlaying: true, streamUrl: url, streamTitle: title }),
  closePlayer: () => set({ isPlaying: false, streamUrl: null, streamTitle: null }),
  setMuted: (isMuted) => set({ isMuted }),
  setVolume: (volume) => set({ volume }),
}));
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="app/layout.tsx">
import { ReactQueryProvider } from "@/lib/react-query-provider";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "NEXUS-IPTV",
  description: "High-performance IPTV Player",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="pt-BR" className="dark" suppressHydrationWarning>
      <body className={`${inter.className} antialiased bg-black text-white`}>
        <ReactQueryProvider>
          {children}
        </ReactQueryProvider>
      </body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
import { LoginForm } from "@/components/login-form";

export default function Home() {
  return (
    <main className="relative flex min-h-screen flex-col items-center justify-center overflow-hidden bg-black">
      {/* Background with Gradient/Image */}
      <div className="absolute inset-0 z-0">
         <div className="absolute inset-0 bg-linear-to-tr from-purple-900/40 via-blue-900/20 to-black animate-pulse-slow" />
         <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,var(--tw-gradient-stops))] from-zinc-900/50 via-black to-black" />
         {/* Optional: Add a subtle background image here if requested */}
      </div>

      <div className="z-10 w-full max-w-md px-4">
        <LoginForm />
      </div>
    </main>
  );
}
</file>

<file path="components/category-list.tsx">
'use client';

import { Card, CardContent } from '@/components/ui/card';
import { VirtualGrid } from '@/components/virtual-grid';
import { Category, Channel } from '@/lib/types';
import { useQuery } from '@tanstack/react-query';
import { Clapperboard, Film, Loader2, Search, Tv } from 'lucide-react';
import Link from 'next/link';
import { useSearchParams } from 'next/navigation';
import { Suspense, useMemo } from 'react';

interface CategoryListProps {
  action: string;
  streamAction: string;
  title: string;
  baseRoute: string;
  Icon: React.ElementType;
}

async function fetchCategories(action: string) {
  const res = await fetch(`/api/data?action=${action}`);
  if (!res.ok) throw new Error('Failed to fetch categories');
  return res.json();
}

async function fetchAllStreams(action: string) {
  const res = await fetch(`/api/data?action=${action}`);
  if (!res.ok) throw new Error('Failed to fetch streams');
  return res.json();
}

function CategoryListInner({ action, streamAction, title, baseRoute, Icon }: CategoryListProps) {
  const searchParams = useSearchParams();
  const query = searchParams.get('q') || '';
  
  const { data: categories, isLoading: loadingCategories, error: categoriesError } = useQuery<Category[]>({
    queryKey: ['categories', action],
    queryFn: () => fetchCategories(action),
    refetchOnWindowFocus: false,
    staleTime: 10 * 60 * 1000,
  });
  
  // Buscar todos os streams apenas quando há uma busca
  const { data: allStreams, isLoading: loadingStreams } = useQuery<Channel[]>({
    queryKey: ['allStreams', streamAction],
    queryFn: () => fetchAllStreams(streamAction),
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
    enabled: !!query, // Só busca quando tem query
  });
  
  // Filtrar resultados da busca
  const filteredStreams = useMemo(() => {
    if (!query || !allStreams) return [];
    const lowerQuery = query.toLowerCase();
    return allStreams.filter((item) => item.name.toLowerCase().includes(lowerQuery));
  }, [query, allStreams]);

  const isLoading = loadingCategories || (query && loadingStreams);

  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <span className="ml-2 text-zinc-400">
          {query ? 'Buscando...' : 'Carregando categorias...'}
        </span>
      </div>
    );
  }

  if (categoriesError) {
    return (
      <div className="flex h-full items-center justify-center text-red-500">
        Erro ao carregar categorias. Verifique sua conexão ou credenciais.
      </div>
    );
  }

  // Se há busca, mostrar resultados da busca
  if (query) {
    return (
      <div className="h-full flex flex-col">
        <div className="px-4 py-2 border-b border-zinc-800 mb-2">
          <h1 className="text-xl font-semibold text-white flex items-center gap-2">
            <Search className="w-5 h-5 text-primary" />
            Resultados para &quot;{query}&quot;
            <span className="text-zinc-500 text-sm ml-2">({filteredStreams.length})</span>
          </h1>
        </div>
        {filteredStreams.length > 0 ? (
          <VirtualGrid items={filteredStreams} />
        ) : (
          <div className="flex h-64 items-center justify-center text-zinc-500">
            Nenhum resultado encontrado para &quot;{query}&quot;.
          </div>
        )}
      </div>
    );
  }

  // Sem busca, mostrar categorias normalmente
  return (
    <div className="h-full flex flex-col">
      <div className="px-4 py-2 border-b border-zinc-800 mb-8">
         <h1 className="text-xl font-semibold text-white flex items-center gap-2">
            <Icon className="w-6 h-6 text-primary" />
            {title} 
            <span className="text-zinc-500 text-sm ml-2">({categories?.length || 0} categorias)</span>
         </h1>
      </div>
      <div className="grid grid-cols-2 pt-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 px-4 overflow-auto pb-4">
        {/* Card "Ver Todos" */}
        <Link href={`${baseRoute}/all`}>
          <Card className="group bg-primary/10 border-primary/30 hover:ring-2 p-2 hover:ring-primary transition-all cursor-pointer h-full">
            <CardContent className="p-4 flex flex-col items-center justify-center text-center h-full min-h-25">
              <Search className="w-8 h-8 text-primary mb-2" />
              <p className="text-primary text-sm font-medium">Ver Todos</p>
            </CardContent>
          </Card>
        </Link>
        
        {categories?.map((category) => (
          <Link key={category.id} href={`${baseRoute}/${category.id}`}>
            <Card className="group bg-zinc-900 border-zinc-800 hover:ring-2 p-2 hover:ring-primary transition-all cursor-pointer h-full">
              <CardContent className="p-4 flex flex-col items-center justify-center text-center h-full min-h-25">
                <Icon className="w-8 h-8 text-zinc-500 group-hover:text-primary transition-colors mb-2" />
                <p className="text-white text-sm font-medium line-clamp-2">{category.name}</p>
              </CardContent>
            </Card>
          </Link>
        ))}
      </div>
    </div>
  );
}

export function CategoryList(props: CategoryListProps) {
  return (
    <Suspense fallback={
      <div className="flex h-full items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    }>
      <CategoryListInner {...props} />
    </Suspense>
  );
}

// Convenience exports for specific content types
export function LiveCategoryList() {
  return <CategoryList 
    action="get_live_categories" 
    streamAction="get_live_streams"
    title="Categorias de TV" 
    baseRoute="/dashboard/live" 
    Icon={Tv} 
  />;
}

export function MovieCategoryList() {
  return <CategoryList 
    action="get_vod_categories" 
    streamAction="get_vod_streams"
    title="Categorias de Filmes" 
    baseRoute="/dashboard/movies" 
    Icon={Film} 
  />;
}

export function SeriesCategoryList() {
  return <CategoryList 
    action="get_series_categories" 
    streamAction="get_series"
    title="Categorias de Séries" 
    baseRoute="/dashboard/series" 
    Icon={Clapperboard} 
  />;
}
</file>

<file path="components/content-info-dialog.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogDescription, DialogTitle } from '@/components/ui/dialog';
import { Channel, XtreamEpgShortResponse, XtreamEpisode, XtreamSeason, XtreamSeriesInfo, XtreamVodInfo } from '@/lib/types';
import { cn } from '@/lib/utils';
import { useAuthStore } from '@/store/useAuthStore';
import { useFavoritesStore } from '@/store/useFavoritesStore';
import { usePlayerStore } from '@/store/usePlayerStore';
import { ChevronDown, Clock, Heart, Loader2, Play, Star } from 'lucide-react';
import Image from 'next/image';
import { useCallback, useEffect, useMemo, useState } from 'react';

interface ContentInfoDialogProps {
  item: Channel | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

function safeDecode(str: string) {
    try {
        if (/^[A-Za-z0-9+/]+={0,2}$/.test(str) && !str.includes(' ')) {
             return atob(str);
        }
        return str;
    } catch (e) {
        console.error("Error decoding string", e);
        return str;
    }
}

export function ContentInfoDialog({ item, open, onOpenChange }: ContentInfoDialogProps) {
    console.log("ContentInfoDialog render", { item, open });
    const [epg, setEpg] = useState<XtreamEpgShortResponse | null>(null);
    const [seriesData, setSeriesData] = useState<XtreamSeriesInfo | null>(null);
    const [vodData, setVodData] = useState<XtreamVodInfo | null>(null);
    const [selectedSeason, setSelectedSeason] = useState<string>('');
    const [loading, setLoading] = useState(false);

    const playChannel = usePlayerStore((state) => state.playChannel);
    const username = useAuthStore((state) => state.username);
    const password = useAuthStore((state) => state.password);
    
    // Favorites - usando selector estável para evitar re-renders
    const favorites = useFavoritesStore((state) => state.favorites);
    const toggleFavorite = useFavoritesStore((state) => state.toggleFavorite);
    
    // Memoizar o estado de favorito para evitar recálculos desnecessários
    const isFavorite = useMemo(() => {
        if (!item) return false;
        return favorites.some((fav) => fav.id === item.id);
    }, [favorites, item]);

    const handleToggleFavorite = useCallback(() => {
        if (item) {
            toggleFavorite(item);
        }
    }, [item, toggleFavorite]);

    // Reset state e fetch data quando o dialog abre ou o item muda
    useEffect(() => {
        if (!open || !item) {
            return;
        }

        // Reset state
        setEpg(null);
        setSeriesData(null);
        setVodData(null);
        setSelectedSeason('');
        setLoading(true);

        let isMounted = true;
        const controller = new AbortController();

        const fetchData = async () => {
            try {
                if (item.stream_type === 'live' || !item.stream_type) {
                    const res = await fetch(
                        `/api/data?action=get_short_epg&stream_id=${item.id}&limit=1`,
                        { signal: controller.signal }
                    );
                    const data = await res.json();
                    if (isMounted) setEpg(data);
                } else if (item.stream_type === 'series') {
                    const res = await fetch(
                        `/api/data?action=get_series_info&series_id=${item.id}`,
                        { signal: controller.signal }
                    );
                    const data = await res.json();
                    if (isMounted) {
                        setSeriesData(data);
                        if (data.seasons && data.seasons.length > 0) {
                            setSelectedSeason(data.seasons[0].season_number?.toString());
                        }
                    }
                } else if (item.stream_type === 'movie') {
                    const res = await fetch(
                        `/api/data?action=get_vod_info&vod_id=${item.id}`,
                        { signal: controller.signal }
                    );
                    const data = await res.json();
                    if (isMounted) {
                        setVodData(data);
                    }
                }
            } catch (e) {
                if (e instanceof Error && e.name !== 'AbortError') {
                    console.error("Fetch error", e);
                }
            } finally {
                if (isMounted) setLoading(false);
            }
        };

        fetchData();

        return () => {
            isMounted = false;
            controller.abort();
        };
    }, [open, item?.id, item?.stream_type, item]);

    const handlePlayItem = useCallback(() => {
        if (!item || !username || !password) return;

        let streamUrl = '';
        if (item.stream_type === 'movie') {
            const ext = item.extension || 'mp4';
            streamUrl = `/api/nexus/movie/${username}/${password}/${item.id}.${ext}`;
            playChannel(streamUrl, item.name);
            onOpenChange(false);
        } else {
             // Fallback/Default
             streamUrl = `/api/nexus/live/${username}/${password}/${item.id}.m3u8`;
             playChannel(streamUrl, item.name);
             onOpenChange(false);
        }
    }, [item, username, password, playChannel, onOpenChange]);

    const handlePlayEpisode = useCallback((episode: XtreamEpisode) => {
        if (!username || !password) return;
        const streamId = episode.id;
        const ext = episode.container_extension || 'mp4';
        const streamUrl = `/api/nexus/series/${username}/${password}/${streamId}.${ext}`;
        
        playChannel(streamUrl, `${episode.title} - ${item?.name}`);
        onOpenChange(false);
    }, [username, password, playChannel, item?.name, onOpenChange]);

    if (!item) return null;

    const currentProgram = epg?.epg_listings?.[0];
    
    // Determinar a melhor imagem de capa disponível
    const coverImage = vodData?.info?.cover_big || 
                       vodData?.info?.movie_image || 
                       seriesData?.info?.cover || 
                       item.logo;
    
    const hasLargeCover = !!(vodData?.info?.cover_big || 
                             vodData?.info?.movie_image || 
                             seriesData?.info?.cover);

    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent className="sm:max-w-3xl bg-zinc-900 border-zinc-800 p-0 overflow-hidden text-white max-h-[90vh] flex flex-col">
                {/* Header com imagem grande (para filmes/séries com capa) ou compacto (para canais) */}
                {hasLargeCover ? (
                    <div className="relative h-80 w-full shrink-0 bg-black">
                        <Image 
                            src={coverImage!} 
                            alt={item.name} 
                            fill 
                            className="object-cover z-0"
                            unoptimized
                        />
                        <div className="absolute inset-0 bg-linear-to-t from-zinc-900 via-zinc-900/60 to-transparent z-10" />
                        
                        {/* Título sobreposto na imagem */}
                        <div className="absolute bottom-0 left-0 right-0 p-6 z-20">
                            <div className="flex items-start justify-between gap-4">
                                <div className="flex-1">
                                    <DialogTitle className="text-3xl font-bold text-white drop-shadow-lg">
                                        {item.name}
                                    </DialogTitle>
                                    <DialogDescription className="text-zinc-200 drop-shadow-md text-base mt-1">
                                       {item.stream_type === 'live' || !item.stream_type ? 'TV Ao Vivo' : 
                                        item.stream_type === 'movie' ? 'Filme' : 'Série'}
                                    </DialogDescription>
                                </div>
                                <Button
                                    variant="outline"
                                    size="icon"
                                    className={cn(
                                        "shrink-0 border-zinc-600/50 bg-zinc-900/80 backdrop-blur-sm hover:bg-zinc-800",
                                        isFavorite && "border-red-600 bg-red-600/20 hover:bg-red-600/30"
                                    )}
                                    onClick={handleToggleFavorite}
                                >
                                    <Heart className={cn(
                                        "w-5 h-5",
                                        isFavorite ? "fill-red-600 text-red-600" : "text-white"
                                    )} />
                                </Button>
                            </div>
                        </div>
                    </div>
                ) : (
                    <div className="relative w-full shrink-0 bg-zinc-950 border-b border-zinc-800">
                        <div className="flex items-start gap-4 p-6">
                            {/* Logo pequeno lateral */}
                            {item.logo && (
                                <div className="relative h-24 w-24 shrink-0 rounded-lg overflow-hidden bg-zinc-900 border border-zinc-800">
                                    <Image 
                                        src={item.logo} 
                                        alt={item.name} 
                                        fill 
                                        className="object-contain p-2"
                                        unoptimized
                                    />
                                </div>
                            )}
                            
                            <div className="flex-1 min-w-0">
                                <div className="flex items-start justify-between gap-4">
                                    <div className="flex-1">
                                        <DialogTitle className="text-2xl font-bold">{item.name}</DialogTitle>
                                        <DialogDescription className="text-zinc-400 mt-1">
                                           {item.stream_type === 'live' || !item.stream_type ? 'TV Ao Vivo' : 
                                            item.stream_type === 'movie' ? 'Filme' : 'Série'}
                                        </DialogDescription>
                                    </div>
                                    <Button
                                        variant="outline"
                                        size="icon"
                                        className={cn(
                                            "shrink-0 border-zinc-700 hover:bg-zinc-800",
                                            isFavorite && "border-red-600 bg-red-600/10 hover:bg-red-600/20"
                                        )}
                                        onClick={handleToggleFavorite}
                                    >
                                        <Heart className={cn(
                                            "w-5 h-5",
                                            isFavorite ? "fill-red-600 text-red-600" : "text-zinc-400"
                                        )} />
                                    </Button>
                                </div>
                            </div>
                        </div>
                    </div>
                )}
                
                <div className="px-6 pb-6 pt-4 flex-1 overflow-auto">
                    {/* MOVIE/SERIES INFO quando tem capa grande */}
                    {hasLargeCover && (item.stream_type === 'movie' || item.stream_type === 'series') && (
                        <div className="mb-4 space-y-3">
                            {/* Rating para filmes/séries */}
                            {(vodData?.info?.rating || seriesData?.info?.rating) && (
                                <div className="flex items-center gap-2">
                                    <Star className="w-4 h-4 text-yellow-500 fill-yellow-500" />
                                    <span className="text-sm font-medium text-white">
                                        {vodData?.info?.rating || seriesData?.info?.rating}
                                    </span>
                                    {(vodData?.info?.rating_5based || seriesData?.info?.rating_5based) && (
                                        <span className="text-xs text-zinc-500">
                                            ({vodData?.info?.rating_5based || seriesData?.info?.rating_5based}/5)
                                        </span>
                                    )}
                                </div>
                            )}
                            
                            {/* Sinopse */}
                            {(vodData?.info?.plot || vodData?.info?.description || seriesData?.info?.plot) && (
                                <p className="text-sm text-zinc-300 leading-relaxed">
                                    {vodData?.info?.plot || vodData?.info?.description || seriesData?.info?.plot}
                                </p>
                            )}
                            
                            {/* Metadados */}
                            {(vodData?.info?.director || vodData?.info?.actors || vodData?.info?.cast || 
                              seriesData?.info?.director || seriesData?.info?.cast) && (
                                <div className="text-xs text-zinc-400 space-y-1.5 pt-2 border-t border-zinc-800">
                                    {(vodData?.info?.director || seriesData?.info?.director) && (
                                        <p>
                                            <span className="text-zinc-500 font-medium">Diretor:</span>{' '}
                                            {vodData?.info?.director || seriesData?.info?.director}
                                        </p>
                                    )}
                                    {(vodData?.info?.actors || vodData?.info?.cast || seriesData?.info?.cast) && (
                                        <p className="line-clamp-2">
                                            <span className="text-zinc-500 font-medium">Elenco:</span>{' '}
                                            {vodData?.info?.actors || vodData?.info?.cast || seriesData?.info?.cast}
                                        </p>
                                    )}
                                    {(vodData?.info?.genre || seriesData?.info?.genre) && (
                                        <p>
                                            <span className="text-zinc-500 font-medium">Gênero:</span>{' '}
                                            {vodData?.info?.genre || seriesData?.info?.genre}
                                        </p>
                                    )}
                                </div>
                            )}
                        </div>
                    )}
                
                     {/* SERIES DESCRIPTION - só para layout compacto sem capa grande */}
                     {item.stream_type === 'series' && seriesData?.info?.plot && !hasLargeCover && (
                        <p className="text-sm text-zinc-300 mb-4 line-clamp-3">
                            {seriesData.info.plot}
                        </p>
                    )}

                    {/* MOVIE DESCRIPTION & RATING - só para layout compacto sem capa grande */}
                    {item.stream_type === 'movie' && vodData?.info && !hasLargeCover && (
                        <div className="mb-4 space-y-2">
                            {vodData.info.rating && (
                                <div className="flex items-center gap-2">
                                    <Star className="w-4 h-4 text-yellow-500 fill-yellow-500" />
                                    <span className="text-sm font-medium text-white">
                                        {vodData.info.rating}
                                    </span>
                                    {vodData.info.rating_5based && (
                                        <span className="text-xs text-zinc-500">
                                            ({vodData.info.rating_5based}/5)
                                        </span>
                                    )}
                                </div>
                            )}
                            {(vodData.info.plot || vodData.info.description) && (
                                <p className="text-sm text-zinc-300 line-clamp-3">
                                    {vodData.info.plot || vodData.info.description}
                                </p>
                            )}
                            {(vodData.info.director || vodData.info.actors || vodData.info.cast) && (
                                <div className="text-xs text-zinc-400 space-y-1">
                                    {vodData.info.director && (
                                        <p><span className="text-zinc-500">Diretor:</span> {vodData.info.director}</p>
                                    )}
                                    {(vodData.info.actors || vodData.info.cast) && (
                                        <p className="line-clamp-2">
                                            <span className="text-zinc-500">Elenco:</span> {vodData.info.actors || vodData.info.cast}
                                        </p>
                                    )}
                                </div>
                            )}
                        </div>
                    )}


                    <div className="space-y-4">
                        {/* LIVE EPG SECTION */}
                        {(item.stream_type === 'live' || !item.stream_type) && (
                            <div className="bg-zinc-950/80 p-5 rounded-xl border border-zinc-800 min-h-30">
                                {loading ? (
                                    <div className="flex items-center justify-center h-full py-4">
                                        <Loader2 className="animate-spin text-primary w-6 h-6" />
                                        <span className="ml-2 text-zinc-500 text-sm">Carregando guia...</span>
                                    </div>
                                ) : currentProgram ? (
                                    <div className="space-y-2 animate-in fade-in duration-300">
                                        <div className="flex items-center gap-2 text-red-500 font-medium uppercase text-xs tracking-wider">
                                            <div className="w-2 h-2 rounded-full bg-red-500 animate-pulse" />
                                            <span>No Ar</span>
                                        </div>
                                        <h3 className="text-xl font-semibold text-white leading-tight">
                                            {safeDecode(currentProgram.title)}
                                        </h3>
                                        <p className="text-sm text-zinc-400 leading-relaxed">
                                            {safeDecode(currentProgram.description)}
                                        </p>
                                        <div className="text-xs text-zinc-500 font-mono mt-3 pt-3 border-t border-zinc-900 flex items-center gap-2">
                                            <Clock className="w-3 h-3" />
                                            {currentProgram.start} - {currentProgram.end}
                                        </div>
                                    </div>
                                ) : (
                                    <div className="flex flex-col items-center justify-center h-full text-zinc-500 py-4 gap-2">
                                        <Clock className="w-8 h-8 opacity-20" />
                                        <p className="text-sm">Informações de programação indisponíveis.</p>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* SERIES SEASONS & EPISODES */}
                        {item.stream_type === 'series' && (
                            <div className="space-y-4">
                                {loading ? (
                                     <div className="flex justify-center p-8">
                                         <Loader2 className="animate-spin text-primary w-8 h-8" />
                                     </div>
                                ) : seriesData ? (
                                    <>
                                        {/* Season Selector */}
                                        <div className="relative">
                                            <select 
                                                className="w-full bg-zinc-950 border border-zinc-800 text-white rounded-md p-3 appearance-none focus:outline-none focus:ring-2 focus:ring-primary"
                                                value={selectedSeason}
                                                onChange={(e) => setSelectedSeason(e.target.value)}
                                            >
                                                {seriesData.seasons.map((season: XtreamSeason) => (
                                                    <option key={season.season_number} value={season.season_number}>
                                                        {season.name || `Temporada ${season.season_number}`}
                                                    </option>
                                                ))}
                                            </select>
                                            <ChevronDown className="absolute right-3 top-3.5 w-5 h-5 text-zinc-500 pointer-events-none" />
                                        </div>

                                        {/* Episodes List */}
                                        <div className="flex flex-col gap-2 max-h-62.5 overflow-y-auto pr-2 custom-scrollbar">
                                            {selectedSeason && seriesData.episodes && seriesData.episodes[selectedSeason] ? (
                                                seriesData.episodes[selectedSeason].map((episode: XtreamEpisode) => (
                                                    <div 
                                                        key={episode.id} 
                                                        className="flex items-center gap-3 p-3 bg-zinc-950/50 hover:bg-zinc-800 rounded-lg group cursor-pointer transition-colors border border-zinc-800/50"
                                                        onClick={() => handlePlayEpisode(episode)}
                                                    >
                                                        <div className="shrink-0 w-8 h-8 rounded-full bg-zinc-900 flex items-center justify-center group-hover:bg-primary transition-colors">
                                                            <Play className="w-4 h-4 text-zinc-400 group-hover:text-black fill-current ml-0.5" />
                                                        </div>
                                                        <div className="flex-1 min-w-0">
                                                            <p className="text-sm font-medium text-white truncate">
                                                                {episode.episode_num}. {episode.title}
                                                            </p>
                                                            <p className="text-xs text-zinc-500">
                                                                {episode.container_extension?.toUpperCase()}
                                                            </p>
                                                        </div>
                                                    </div>
                                                ))
                                            ) : (
                                                <p className="text-zinc-500 text-center py-4">Nenhum episódio encontrado.</p>
                                            )}
                                        </div>
                                    </>
                                ) : (
                                    <p className="text-zinc-500 text-center">Erro ao carregar séries.</p>
                                )}
                            </div>
                        )}
                        
                         {/* MOVIE PLAY BUTTON */}
                         {item.stream_type === 'movie' && (
                             <Button 
                                className="w-full text-lg font-medium shadow-lg hover:shadow-primary/20 transition-all" 
                                size="lg"
                                onClick={handlePlayItem}
                                disabled={loading}
                            >
                                {loading ? (
                                    <>
                                        <Loader2 className="animate-spin w-5 h-5 mr-2" />
                                        Carregando...
                                    </>
                                ) : (
                                    <>
                                        <Play className="fill-current w-5 h-5 mr-2" />
                                        Assistir Agora
                                    </>
                                )}
                            </Button>
                        )}
                        
                        {/* LIVE PLAY BUTTON */}
                        {(item.stream_type === 'live' || !item.stream_type) && (
                             <Button 
                                className="w-full mt-4 text-lg font-medium shadow-lg hover:shadow-primary/20 transition-all" 
                                size="lg"
                                onClick={handlePlayItem}
                            >
                                <Play className="fill-current w-5 h-5 mr-2" />
                                Assistir Agora
                            </Button>
                        )}

                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
}
</file>

<file path="components/content-layout.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { VirtualGrid } from '@/components/virtual-grid';
import { Channel } from '@/lib/types';
import { useQuery } from '@tanstack/react-query';
import { ArrowLeft, Loader2 } from 'lucide-react';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { Suspense, useMemo } from 'react';

interface ContentLayoutProps {
  action: string;
  categoryId?: string;
  title: string;
}

async function fetchData(action: string, categoryId?: string) {
  const params = new URLSearchParams({ action });
  if (categoryId) params.append('category_id', categoryId);
  
  const res = await fetch(`/api/data?${params.toString()}`);
  if (!res.ok) throw new Error('Failed to fetch data');
  return res.json();
}

function ContentLayoutInner({ action, categoryId, title }: ContentLayoutProps) {
  const searchParams = useSearchParams();
  const query = searchParams.get('q') || '';
  const router = useRouter();
  const pathname = usePathname();

  const { data, isLoading, error } = useQuery<Channel[]>({
    queryKey: ['content', action, categoryId],
    queryFn: () => fetchData(action, categoryId),
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
  });

  const filteredData = useMemo(() => {
    if (!data) return [];
    if (!query) return data;
    const lowerQuery = query.toLowerCase();
    return data.filter((item) => item.name.toLowerCase().includes(lowerQuery));
  }, [data, query]);

  // Determine parent route for "Back" button
  const handleBack = () => {
    // If we are deep in /dashboard/live/[id], go back to /dashboard/live
    const segments = pathname.split('/');
    if (segments.length > 3) {
        segments.pop(); 
        router.push(segments.join('/'));
    } else {
        router.back();
    }
  };

  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <span className="ml-2 text-zinc-400">Carregando lista...</span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex h-full items-center justify-center text-red-500">
        Erro ao carregar conteúdo. Verifique sua conexão ou credenciais.
      </div>
    );
  }

  // Determine if we should show back button (any nested page)
  const showBackButton = pathname.split('/').length > 3;

  return (
    <div className="h-full flex flex-col">
      <div className="px-4 py-2 border-b border-zinc-800 mb-2 flex items-center gap-4">
         {showBackButton && (
            <Button variant="ghost" size="icon" onClick={handleBack} className="text-zinc-400 hover:text-white">
                <ArrowLeft className="w-5 h-5" />
            </Button>
         )}
         <h1 className="text-xl font-semibold text-white">
            {title} <span className="text-zinc-500 text-sm ml-2">({filteredData.length})</span>
         </h1>
      </div>
      {filteredData.length > 0 ? (
        <VirtualGrid items={filteredData} />
      ) : (
        <div className="flex h-64 items-center justify-center text-zinc-500">
          Nenhum item encontrado.
        </div>
      )}
    </div>
  );
}

export function ContentLayout(props: ContentLayoutProps) {
  return (
    <Suspense fallback={
      <div className="flex h-full items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    }>
      <ContentLayoutInner {...props} />
    </Suspense>
  );
}
</file>

<file path="components/login-form.tsx">
"use client"

import { useAuthStore } from "@/store/useAuthStore"
import { zodResolver } from "@hookform/resolvers/zod"
import { Globe, Loader2, Lock, Tv, User } from "lucide-react"
import { useRouter } from "next/navigation"
import { useState } from "react"
import { useForm } from "react-hook-form"
import { z } from "zod"

import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"

const formSchema = z.object({
  dns: z.string().min(1, "DNS é obrigatório").url("Insira uma URL válida (ex: http://servidor.com:80)"),
  username: z.string().min(1, "Usuário é obrigatório"),
  password: z.string().min(1, "Senha é obrigatória"),
})

export function LoginForm() {
  const router = useRouter()
  const setCredentials = useAuthStore((state) => state.setCredentials)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [successMessage, setSuccessMessage] = useState<string | null>(null)

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      dns: "",
      username: "",
      password: "",
    },
  })

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true)
    setError(null)
    setSuccessMessage(null)
    
    try {
      // Clean trailing slash from DNS
      let cleanDns = values.dns.replace(/\/$/, "")
      
      console.log('[Login] Original DNS:', cleanDns)
      
      // Tentar conectar
      let testUrl = `${cleanDns}/player_api.php?username=${values.username}&password=${values.password}&action=get_live_categories`
      
      console.log('[Login] Testing connection to:', testUrl.replace(values.password, '***'))
      
      let response = await fetch(testUrl, {
        signal: AbortSignal.timeout(15000),
        headers: {
          'User-Agent': 'Nexus-IPTV/1.0',
        },
      })
      
      console.log('[Login] Response status:', response.status, response.statusText)
      
      // Se 404 e está usando HTTP, tentar HTTPS automaticamente
      if (response.status === 404 && cleanDns.startsWith('http://')) {
        console.log('[Login] Got 404 with HTTP, trying HTTPS automatically...')
        
        const httpsUrl = cleanDns.replace('http://', 'https://')
        testUrl = `${httpsUrl}/player_api.php?username=${values.username}&password=${values.password}&action=get_live_categories`
        
        console.log('[Login] Retrying with HTTPS:', testUrl.replace(values.password, '***'))
        
        response = await fetch(testUrl, {
          signal: AbortSignal.timeout(15000),
          headers: {
            'User-Agent': 'Nexus-IPTV/1.0',
          },
        })
        
        console.log('[Login] HTTPS response status:', response.status, response.statusText)
        
        // Se funcionou com HTTPS, atualizar o DNS
        if (response.ok) {
          console.log('[Login] ✅ HTTPS worked! Updating DNS to use HTTPS')
          cleanDns = httpsUrl
          setSuccessMessage('✅ Servidor detectado com HTTPS! URL corrigida automaticamente.')
        }
      }
      
      if (!response.ok) {
        // Erros específicos por status code
        if (response.status === 404) {
          throw new Error(
            `Servidor não encontrado (404).\n\n` +
            `Verifique:\n` +
            `• URL correta incluindo protocolo (http:// ou https://)\n` +
            `• Porta se necessário (ex: :8080, :25461)\n` +
            `• Servidor está online\n\n` +
            `Testado: ${testUrl.replace(values.password, '***')}`
          )
        } else if (response.status === 401 || response.status === 403) {
          throw new Error('Usuário ou senha incorretos')
        } else {
          throw new Error(`Erro do servidor: ${response.status} ${response.statusText}`)
        }
      }
      
      console.log('[Login] Connection successful!')
      
      console.log('[Login] Connection successful!')
      
      // Tentar parsear a resposta
      const data = await response.json()
      
      if (!Array.isArray(data) && data.user_info?.auth === 0) {
        throw new Error('Credenciais inválidas')
      }
      
      console.log('[Login] ✅ Validation passed! Saving credentials with DNS:', cleanDns)
      
      // Tudo OK, salvar credenciais (com protocolo correto)
      setCredentials(cleanDns, values.username, values.password)
      router.push("/dashboard")
      
    } catch (error) {
      console.error('Login error:', error)
      
      if (error instanceof Error) {
        if (error.name === 'TimeoutError') {
          setError('Tempo esgotado. O servidor demorou muito para responder.')
        } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          setError('Erro de conexão. Verifique se o DNS está correto e acessível.')
        } else {
          setError(error.message)
        }
      } else {
        setError('Erro desconhecido ao conectar')
      }
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Card className="w-full max-w-md border-0 bg-black/40 backdrop-blur-xl shadow-2xl text-white ring-1 ring-white/10">
      <CardHeader className="space-y-1 text-center">
        <div className="flex justify-center mb-4">
            <div className="p-3 bg-primary/20 rounded-full ring-1 ring-primary/50">
                <Tv className="w-8 h-8 text-primary" />
            </div>
        </div>
        <CardTitle className="text-2xl font-bold tracking-tight">NEXUS IPTV</CardTitle>
        <CardDescription className="text-zinc-400">
          Entre com suas credenciais Xtream Codes
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="dns"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-zinc-300">Servidor DNS</FormLabel>
                  <FormControl>
                    <div className="relative">
                        <Globe className="absolute left-3 top-2.5 h-4 w-4 text-zinc-500" />
                        <Input 
                            placeholder="http://servidor.com:8080" 
                            className="pl-9 bg-black/50 border-zinc-800 text-white placeholder:text-zinc-600 focus-visible:ring-primary" 
                            {...field} 
                        />
                    </div>
                  </FormControl>
                  <p className="text-xs text-zinc-500 mt-1">
                    ⚠️ Inclua a porta se necessário (ex: :8080, :80, :25461)
                  </p>
                  <FormMessage className="text-red-400" />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="username"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-zinc-300">Usuário</FormLabel>
                  <FormControl>
                     <div className="relative">
                        <User className="absolute left-3 top-2.5 h-4 w-4 text-zinc-500" />
                        <Input 
                            placeholder="Seu usuário" 
                            className="pl-9 bg-black/50 border-zinc-800 text-white placeholder:text-zinc-600 focus-visible:ring-primary" 
                            {...field} 
                        />
                    </div>
                  </FormControl>
                  <FormMessage className="text-red-400" />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-zinc-300">Senha</FormLabel>
                  <FormControl>
                     <div className="relative">
                        <Lock className="absolute left-3 top-2.5 h-4 w-4 text-zinc-500" />
                        <Input 
                            type="password" 
                            placeholder="••••••" 
                            className="pl-9 bg-black/50 border-zinc-800 text-white placeholder:text-zinc-600 focus-visible:ring-primary" 
                            {...field} 
                        />
                     </div>
                  </FormControl>
                  <FormMessage className="text-red-400" />
                </FormItem>
              )}
            />
            {successMessage && (
              <div className="p-3 rounded-lg bg-green-500/10 border border-green-500/50 text-green-400 text-sm">
                {successMessage}
              </div>
            )}
            {error && (
              <div className="p-3 rounded-lg bg-red-500/10 border border-red-500/50 text-red-400 text-sm whitespace-pre-line">
                {error}
              </div>
            )}
            <Button 
                type="submit" 
                className="w-full bg-primary hover:bg-primary/90 text-primary-foreground font-semibold shadow-lg shadow-primary/20 transition-all duration-300"
                disabled={isLoading}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Conectando...
                </>
              ) : (
                "Entrar"
              )}
            </Button>
          </form>
        </Form>
      </CardContent>
      <CardFooter className="flex flex-col gap-2 text-xs text-zinc-500">
        <p className="text-center">Desenvolvido para alta performance</p>
        <p className="text-center text-zinc-600">
          A conexão será testada antes de salvar as credenciais
        </p>
      </CardFooter>
    </Card>
  )
}
</file>

<file path="package.json">
{
  "name": "nexus-iptv",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.90.20",
    "@tanstack/react-virtual": "^3.13.18",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "hls.js": "^1.6.15",
    "js-cookie": "^3.0.5",
    "lucide-react": "^0.563.0",
    "next": "16.1.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "^7.71.1",
    "tailwind-merge": "^3.4.0",
    "vidstack": "^0.6.15",
    "zod": "^4.3.6",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/js-cookie": "^3.0.6",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}
</file>

<file path="app/api/data/route.ts">
import { Category, Channel, XtreamCategory, XtreamSeries, XtreamStream } from '@/lib/types';
import { NextRequest, NextResponse } from 'next/server';

export const dynamic = 'force-dynamic'; // Prevent caching of credentials

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const action = searchParams.get('action');

  if (!action) {
    return NextResponse.json({ error: 'Missing action parameter' }, { status: 400 });
  }

  // Get credentials from cookies (secure server-side access)
  const dns = request.cookies.get('nexus_dns')?.value;
  const username = request.cookies.get('nexus_username')?.value;
  const password = request.cookies.get('nexus_password')?.value;

  if (!dns || !username || !password) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    console.log('[API] ========== REQUEST START ==========');
    console.log('[API] Original DNS from cookie:', dns);
    console.log('[API] Action:', action);
    console.log('[API] Username:', username);
    console.log('[API] Has password:', !!password);
    
    // Detectar protocolo
    const usesHttps = dns.startsWith('https://');
    const usesHttp = dns.startsWith('http://');
    console.log('[API] Protocol detection:', { usesHttps, usesHttp });
    
    const apiUrl = `${dns}/player_api.php?username=${username}&password=${password}&action=${action}`;
    
    // Check if we need to fetch category_id specifically (for filtered streams)
    const category_id = searchParams.get('category_id');
    const stream_id = searchParams.get('stream_id');
    const series_id = searchParams.get('series_id');
    const vod_id = searchParams.get('vod_id');

    let fetchUrl = apiUrl;
    if (category_id) fetchUrl += `&category_id=${category_id}`;
    if (stream_id) fetchUrl += `&stream_id=${stream_id}`;
    if (series_id) fetchUrl += `&series_id=${series_id}`;
    if (vod_id) fetchUrl += `&vod_id=${vod_id}`;

    console.log('[API] Final URL (with protocol):', fetchUrl.replace(password, '***'));
    console.log('[API] URL protocol:', new URL(fetchUrl).protocol);
    console.log('[API] URL hostname:', new URL(fetchUrl).hostname);
    console.log('[API] URL port:', new URL(fetchUrl).port || 'default');
    
    const fetchOptions = {
      signal: AbortSignal.timeout(30000),
      headers: {
        'User-Agent': 'Nexus-IPTV/1.0',
        'Accept': 'application/json',
      },
      redirect: 'follow' as RequestRedirect, // Seguir redirecionamentos
    };
    
    console.log('[API] Fetch options:', JSON.stringify(fetchOptions, null, 2));
    console.log('[API] Starting fetch...');
    
    const fetchStart = Date.now();
    const res = await fetch(fetchUrl, fetchOptions);
    const fetchDuration = Date.now() - fetchStart;
    
    console.log('[API] ========== RESPONSE RECEIVED ==========');
    console.log('[API] Response time:', fetchDuration + 'ms');
    console.log('[API] Response status:', res.status, res.statusText);
    console.log('[API] Response URL (after redirects):', res.url);
    console.log('[API] Response headers:', JSON.stringify(Object.fromEntries(res.headers.entries()), null, 2));
    console.log('[API] Response redirected:', res.redirected);
    console.log('[API] Response type:', res.type);
    
    if (!res.ok) {
        console.log('[API] ========== ERROR RESPONSE ==========');
        const errorText = await res.text().catch(() => 'No error body');
        console.error('[API] Upstream error details:', {
          status: res.status,
          statusText: res.statusText,
          body: errorText.substring(0, 500),
          url: fetchUrl.replace(password, '***'),
          finalUrl: res.url,
          redirected: res.redirected,
        });
        
        // Se for 404 com HTTP, sugerir tentar HTTPS
        if (res.status === 404 && dns.startsWith('http://')) {
          console.log('[API] 💡 SUGGESTION: 404 with HTTP protocol. Server might require HTTPS.');
          console.log('[API] Try updating DNS to use https:// instead of http://');
          
          return NextResponse.json({ 
            error: 'Upstream server error',
            details: `Server returned ${res.status}: ${res.statusText}`,
            suggestion: 'Servidor retornou 404. Tente usar https:// ao invés de http:// no DNS.',
            upstream_url: dns,
            tested_url: fetchUrl.replace(password, '***'),
          }, { status: res.status });
        }
        
        return NextResponse.json({ 
          error: 'Upstream server error',
          details: `Server returned ${res.status}: ${res.statusText}`,
          upstream_url: dns,
        }, { status: res.status });
    }
    
    console.log('[API] ========== SUCCESS ==========');
    console.log('[API] Starting JSON parse...');

    const data = await res.json();
    
    console.log('[API] JSON parsed successfully');
    console.log('[API] Data type:', Array.isArray(data) ? `array[${data.length}]` : typeof data);
    console.log('[API] First item sample:', Array.isArray(data) && data[0] ? JSON.stringify(data[0]).substring(0, 200) : 'N/A');

    // Optimization Layer for CATEGORIES
    if (action === 'get_live_categories' || action === 'get_vod_categories' || action === 'get_series_categories') {
        if (Array.isArray(data)) {
            const optimized: Category[] = data.map((item: XtreamCategory) => ({
               id: item.category_id,
               name: item.category_name,
            }));
            return NextResponse.json(optimized);
        }
    }

    // Optimization Layer for STREAMS
    if (action === 'get_live_streams' || action === 'get_vod_streams' || action === 'get_series') {
        if (Array.isArray(data)) {
             const type = action === 'get_live_streams' ? 'live' : 
                          action === 'get_vod_streams' ? 'movie' : 'series';

             const optimized: Channel[] = data.map((item: XtreamStream | XtreamSeries) => {
                 const stream = item as XtreamStream;
                 const series = item as XtreamSeries;
                 
                 return {
                    id: stream.stream_id || series.series_id,
                    name: item.name,
                    logo: stream.stream_icon || series.cover,
                    group_id: item.category_id,
                    stream_type: type,
                    extension: stream.container_extension,
                 };
             });
             return NextResponse.json(optimized);
        }
    }

    if (action === 'get_short_epg') {
        // Return EPG data as is, or optimize if needed
        return NextResponse.json(data);
    }

    // Return raw data for other actions (categories, login check)
    return NextResponse.json(data);

  } catch (error) {
    console.error('[API] Fatal error:', error);
    console.error('[API] Request details:', {
      action,
      dns: dns ? `${dns.substring(0, 20)}...` : 'missing',
      hasUsername: !!username,
      hasPassword: !!password,
      errorType: error instanceof Error ? error.constructor.name : typeof error,
      errorMessage: error instanceof Error ? error.message : String(error),
    });
    
    // Erro específico de timeout
    if (error instanceof Error && error.name === 'TimeoutError') {
      return NextResponse.json({ 
        error: 'Request timeout',
        message: 'O servidor Xtream demorou muito para responder (>30s)',
        action,
      }, { status: 504 });
    }
    
    // Erro de rede/conexão
    if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('network'))) {
      return NextResponse.json({ 
        error: 'Network error',
        message: 'Não foi possível conectar ao servidor Xtream. Verifique se o DNS está correto e acessível.',
        details: error.message,
        action,
      }, { status: 502 });
    }
    
    return NextResponse.json({ 
      error: 'Internal Server Error',
      message: error instanceof Error ? error.message : 'Unknown error',
      action,
    }, { status: 500 });
  }
}
</file>

</files>
